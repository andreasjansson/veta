# Veta

_Memory and knowledge base for agents, backed by sqlite_

Veta is a database of notes that an agent can use to keep persistent memory. Notes are organized in tags, and each note can have multiple tags.

Each note has an autogenerated sequential ID, a title, a body, a list of tags, and a last modified date (all required).

Veta runs both as a **CLI** (using local SQLite) and as a **Cloudflare Worker** (using D1). Both share the same core logic written in Rust.

## Table of Contents

- [Claude Code Skill](#claude-code-skill)
- [CLI Usage](#cli-usage)
- [Worker Deployment](#worker-deployment)
  - [Standalone Worker](#standalone-worker)
  - [Multi-Worker Architecture](#multi-worker-architecture-service-bindings)
- [HTTP API](#http-api)
- [Architecture](#architecture)

## Claude Code Skill

Veta includes a skill file that teaches AI coding agents (like Claude Code) how to use Veta as persistent memory. The skill encourages proactive memory writes - documenting decisions, gotchas, and preferences before they're forgotten.

Copy the skill to your Claude Code skills directory:

```bash
# Personal (available across all your projects):
cp -r skills/veta ~/.claude/skills/

# Project-specific (commit to version control):
cp -r skills/veta .claude/skills/
```

## CLI Usage

### Initialize

Before using Veta, initialize a database in your project directory:

```
$ veta init
Initialized veta database in .veta/db.sqlite
```

This creates a `.veta` directory with the SQLite database. Veta commands work from this directory and any subdirectory (it searches up the tree for `.veta`).

### Add note

```
# For long content, pipe stdin to `veta add`
$ echo "my body content..." | veta add --title "My title" --tags "comma,separated,tags"
Added note 1

# For short notes, use `--body`
$ veta add --title "My title" --tags "comma,separated,tags" --body "Short body"
Added note 2
```

### List tags

```
$ veta tags
architecture (7 notes)
implementation-notes (3 notes)
design-decisions (1 note)
testing (11 notes)
deployment (4 notes)
debugging (9 notes)
```

### List notes within a tag

```
# List notes within one or more tags
$ veta ls --tags testing
78: Second issue note (2026-01-28 10:35) -- Second testing body truncated...
41: First testing note (2026-01-26 22:30) -- First testing body truncated...

# List all notes
$ veta ls

# List notes within a time range (SQLite datetime format)
$ veta ls --from "2026-01-01 00:00:00" --to "2026-01-20 00:00:00"

# Human-readable dates are supported
$ veta ls --from "2 days ago"
$ veta ls --from "yesterday" --to "today"
$ veta ls --from "1 week ago" --to "now"

# `--from` and `--to` can be used together or individually
```

To avoid token explosions, we only show the latest 20 notes in the tag by default. To see more notes, use `--head/-n`, where the argument `0` lists all notes in the tag

### Show notes

```
$ veta show 24
# My note about something

body line 1
body line 2
[...]

---

Last modified: 2026-01-07 11:41
Tags: testing,implementation-notes
```

### Edit notes

```
# For long content, pipe stdin to `veta edit`
$ echo "my new body content..." | veta edit 71
Edited note 71: Updated body

# For short notes, use `--body`. You can also edit tags and title
$ veta edit 71 --title "My new title" --tags "comma,separated,tags" --body "Short body"
Edited note 71: Updated title, tags, body
```

### Delete notes

```
$ veta delete 45
Deleted note 45
```

### Grep for notes with regular expressions

`veta grep` searches title and body

```
$ veta grep "test"

# case-sensitive
$ veta grep -C "Claude"

# regular expressions
$ veta grep "claude|openai"

# grep within one or more tags
$ veta grep "cloudflare" --tags deployment,testing
```

## Worker Deployment

Veta publishes a pre-built WASM worker to npm as `@veta/worker`. This can be deployed standalone or integrated into an existing multi-worker Cloudflare project.

### Standalone Worker

For a standalone Veta deployment:

```bash
# Create a new directory
mkdir my-veta && cd my-veta

# Initialize with npm
npm init -y
npm install @veta/worker wrangler

# Create wrangler.toml
cat > wrangler.toml << 'EOF'
name = "my-veta"
main = "node_modules/@veta/worker/dist/shim.mjs"
compatibility_date = "2025-01-01"

[[d1_databases]]
binding = "VETA_DB"
database_name = "my-veta-db"
database_id = "<YOUR_DATABASE_ID>"
EOF

# Create the D1 database
npx wrangler d1 create my-veta-db
# Copy the database_id into wrangler.toml

# Apply migrations
npx wrangler d1 migrations apply my-veta-db --local
npx wrangler d1 migrations apply my-veta-db --remote

# Deploy
npx wrangler deploy
```

### Multi-Worker Architecture (Service Bindings)

For projects with multiple workers (like a monorepo with UI, API, and agent workers), Veta can be added as a service that other workers call via service bindings.

**1. Add the Veta worker to your project:**

Create `src/veta/index.ts`:
```typescript
export { default } from '@veta/worker';
```

Create `wrangler.veta.toml`:
```toml
name = "my-project-veta"
main = "src/veta/index.ts"
compatibility_date = "2025-01-01"

[[d1_databases]]
binding = "VETA_DB"
database_name = "my-project-veta-db"
database_id = "<YOUR_DATABASE_ID>"

[env.production]
name = "my-project-veta"

[[env.production.d1_databases]]
binding = "VETA_DB"
database_name = "my-project-veta-db-prod"
database_id = "<YOUR_PRODUCTION_DATABASE_ID>"
```

**2. Add service binding to consuming workers:**

In the worker that needs to call Veta (e.g., an agent worker), add the service binding:

```toml
# wrangler.agent.toml
[[services]]
binding = "VETA"
service = "my-project-veta"

[[env.production.services]]
binding = "VETA"
service = "my-project-veta"
```

**3. Update your dev script to run all workers:**

```json
{
  "scripts": {
    "dev": "wrangler dev -c wrangler.toml -c wrangler.veta.toml -c wrangler.agent.toml --port 8787"
  }
}
```

**4. Call Veta from your worker:**

```typescript
// In your agent worker
interface Env {
  VETA: Fetcher;
}

// Add a note
const response = await env.VETA.fetch(
  new Request('http://veta/notes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      title: 'Meeting notes',
      body: 'Discussed project timeline...',
      tags: ['meetings', 'project-x'],
    }),
  })
);
const { id } = await response.json();

// Search notes
const searchResponse = await env.VETA.fetch(
  new Request('http://veta/grep?q=timeline&tags=meetings')
);
const notes = await searchResponse.json();
```

## HTTP API

The worker exposes a RESTful HTTP API:

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/notes` | Create a note. Body: `{title, body, tags}` |
| `GET` | `/notes` | List notes. Query: `?tags=a,b&limit=20` |
| `GET` | `/notes/:id` | Get a single note |
| `PATCH` | `/notes/:id` | Update a note. Body: `{title?, body?, tags?}` |
| `DELETE` | `/notes/:id` | Delete a note |
| `GET` | `/tags` | List all tags with note counts |
| `GET` | `/grep` | Search notes. Query: `?q=pattern&tags=a,b&case_sensitive=true` |

## Architecture

Veta is written in Rust and compiles to both native (CLI) and WASM (Worker) targets. The architecture maximizes code sharing between the two.

```
veta/
├── crates/
│   ├── veta-core/        # Shared: types, validation, business logic
│   ├── veta-sqlite/      # Native: rusqlite Database implementation
│   ├── veta-d1/          # WASM: D1 Database implementation
│   ├── veta-cli/         # Native: CLI binary
│   └── veta-worker/      # WASM: Cloudflare Worker
└── schema/
    └── migrations/       # Shared SQL migrations
```

### Crates

**`veta-core`** — Pure business logic with no I/O dependencies. Defines:
- Data types (`Note`, `Tag`, `NoteQuery`, etc.)
- The `Database` trait (async, `?Send` for WASM compatibility)
- `VetaService<D: Database>` containing all business logic

**`veta-sqlite`** — Implements `Database` trait using `rusqlite`. Only compiled for native targets.

**`veta-d1`** — Implements `Database` trait using Cloudflare's D1 via `workers-rs`. Only compiled for `wasm32-unknown-unknown`.

**`veta-cli`** — The `veta` command-line tool. Uses `veta-core` + `veta-sqlite`.

**`veta-worker`** — The Cloudflare Worker entry point. Uses `veta-core` + `veta-d1`. Exposes the HTTP API via `workers-rs` Router.

### Database Trait

The key abstraction enabling code sharing:

```rust
#[async_trait(?Send)]  // ?Send required for WASM compatibility
pub trait Database {
    async fn add_note(&self, note: CreateNote) -> Result<i64, Error>;
    async fn get_note(&self, id: i64) -> Result<Option<Note>, Error>;
    async fn list_notes(&self, query: NoteQuery) -> Result<Vec<Note>, Error>;
    async fn update_note(&self, id: i64, update: UpdateNote) -> Result<(), Error>;
    async fn delete_note(&self, id: i64) -> Result<bool, Error>;
    async fn list_tags(&self) -> Result<Vec<TagCount>, Error>;
    async fn grep(&self, pattern: &str, tags: Option<&[String]>, case_sensitive: bool) -> Result<Vec<Note>, Error>;
}
```

All business logic in `VetaService` is generic over this trait, meaning it works identically whether backed by SQLite or D1.

### Build Targets

| Crate | Native | WASM |
|-------|--------|------|
| `veta-core` | ✓ | ✓ |
| `veta-sqlite` | ✓ | ✗ |
| `veta-d1` | ✗ | ✓ |
| `veta-cli` | ✓ | ✗ |
| `veta-worker` | ✗ | ✓ |
