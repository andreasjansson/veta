# Veta

_Memory and knowledge base for agents, on the command line or as a Cloudflare worker_

Veta is a database of notes that an agent can use to keep persistent memory. Notes are organized in tags, each note can have multiple tags.

A note has an autogenerated sequential ID, a title, a body, a list of tags, optional references (source code paths, URLs, documentation links, etc.), and a last modified date.

Veta runs both as a **CLI** (using local SQLite) and as a **Cloudflare Worker** (using D1). Both share the same core logic written in Rust.

## Table of Contents

- [Installation](#installation)
- [Claude Code Skill](#claude-code-skill)
- [CLI Usage](#cli-usage)
- [Worker Deployment](#worker-deployment)
  - [Standalone Worker](#standalone-worker)
  - [Multi-Worker Architecture](#multi-worker-architecture-service-bindings)
- [HTTP API](#http-api)
- [Architecture](#architecture)

## Installation

### Via Homebrew (macOS/Linux)

```bash
brew install andreasjansson/tap/veta
```

### Via Cargo

```bash
cargo install veta-cli
```

### Pre-built binaries

Download from the [releases page](https://github.com/andreasjansson/veta/releases). Binaries are available for:
- Linux (x86_64, ARM64)
- macOS (Intel, Apple Silicon)
- Windows (x86_64, ARM64)

### From source

```bash
git clone https://github.com/andreasjansson/veta.git
cd veta
cargo install --path crates/veta-cli
```

## Claude Code Skill

Veta includes a skill file that teaches AI coding agents (like Claude Code) how to use Veta as persistent memory. The skill encourages proactive memory writes - documenting decisions, gotchas, and preferences before they're forgotten.

Copy the skill to your Claude Code skills directory:

```bash
# Personal (available across all your projects):
cp -r skills/veta ~/.claude/skills/

# Project-specific (commit to version control):
cp -r skills/veta .claude/skills/
```

## CLI Usage

### Initialize

Before using Veta, initialize a database in your project directory:

```
$ veta init
Initialized veta database in .veta/db.sqlite
```

This creates a `.veta` directory with the SQLite database. Veta commands work from this directory and any subdirectory (it searches up the tree for `.veta`).

### Add note

```
# For long content, pipe stdin to `veta add`
$ echo "my body content..." | veta add --title "My title" --tags "comma,separated,tags"
Added note 1

# For short notes, use `--body`
$ veta add --title "My title" --tags "comma,separated,tags" --body "Short body"
Added note 2

# Add references to source code, URLs, documentation, etc.
$ veta add --title "Auth bug fix" --tags "debugging" --body "Fixed JWT expiry" \
    --references "src/auth.rs:42,https://jwt.io/introduction"
Added note 3
```

References are optional pointers to external resources like source code locations, URLs, or documentation links that provide context for the note.

### List tags

```
$ veta tags
architecture (7 notes)
implementation-notes (3 notes)
design-decisions (1 note)
testing (11 notes)
deployment (4 notes)
debugging (9 notes)
```

### List notes within a tag

```
# List notes within one or more tags
$ veta ls testing
78: Second issue note (2026-01-28 10:35) -- Second testing body truncated...
41: First testing note (2026-01-26 22:30) -- First testing body truncated...

# List all notes
$ veta ls

# List notes within a time range (SQLite datetime format)
$ veta ls --from "2026-01-01 00:00:00" --to "2026-01-20 00:00:00"

# Human-readable dates are supported
$ veta ls debugging --from "2 days ago"
$ veta ls --from "yesterday" --to "today"
$ veta ls gotchas --from "1 week ago" --to "now"

# `--from` and `--to` can be used together or individually
```

To avoid token explosions, we only show the latest 100 notes by default. If there are more, a message like `[Showing the latest 100/250 notes]` is displayed. Use `--head/-n` to change the limit, where `0` shows all notes.

### Show notes

```
$ veta show 24
# My note about something

body line 1
body line 2
[...]

---

Last modified: 2026-01-07 11:41
Tags: testing,implementation-notes
References:
  - src/auth.rs:42
  - https://jwt.io/introduction
```

References are only shown if the note has any.

Show multiple notes at once:

```
$ veta show 1,2,3
```

Use `--head/-n` to show only the first n lines of each note body:

```
$ veta show 24 -n 5
```

### Edit notes

```
# For long content, pipe stdin to `veta edit`
$ echo "my new body content..." | veta edit 71
Edited note 71: Updated body

# For short notes, use `--body`. You can also edit tags, title, and references
$ veta edit 71 --title "My new title" --tags "comma,separated,tags" --body "Short body"
Edited note 71: Updated title, tags, body

# Update references
$ veta edit 71 --references "src/new_file.rs,https://docs.example.com"
Edited note 71: Updated references
```

### Delete notes

```
$ veta delete 45
Deleted note 45
```

### Grep for notes with regular expressions

`veta grep` searches title and body

```
$ veta grep "test"

# case-sensitive
$ veta grep -C "Claude"

# regular expressions
$ veta grep "claude|openai"

# grep within one or more tags
$ veta grep "cloudflare" --tags deployment,testing
```

## Worker Deployment

Veta publishes a pre-built WASM worker to npm as `veta`. This can be deployed standalone or integrated into an existing multi-worker Cloudflare project.

### Standalone Worker

For a standalone Veta deployment:

```bash
# Create a new directory
mkdir my-veta && cd my-veta

# Initialize with npm
npm init -y
npm install veta wrangler

# Create wrangler.toml
cat > wrangler.toml << 'EOF'
name = "my-veta"
main = "node_modules/veta/build/worker/shim.mjs"
compatibility_date = "2025-01-01"

[[d1_databases]]
binding = "VETA_DB"
database_name = "my-veta-db"
database_id = "<YOUR_DATABASE_ID>"
EOF

# Create the D1 database
npx wrangler d1 create my-veta-db
# Copy the database_id into wrangler.toml

# Apply migrations
npx wrangler d1 migrations apply my-veta-db --local
npx wrangler d1 migrations apply my-veta-db --remote

# Deploy
npx wrangler deploy
```

### Multi-Worker Architecture (Service Bindings)

For projects with multiple workers (like a monorepo with UI, API, and agent workers), Veta can be added as a service that other workers call via service bindings.

**1. Add the Veta worker to your project:**

Create `src/veta/index.ts`:
```typescript
export { default } from 'veta';
```

Create `wrangler.veta.toml`:
```toml
name = "my-project-veta"
main = "src/veta/index.ts"
compatibility_date = "2025-01-01"

[[d1_databases]]
binding = "VETA_DB"
database_name = "my-project-veta-db"
database_id = "<YOUR_DATABASE_ID>"

[env.production]
name = "my-project-veta"

[[env.production.d1_databases]]
binding = "VETA_DB"
database_name = "my-project-veta-db-prod"
database_id = "<YOUR_PRODUCTION_DATABASE_ID>"
```

**2. Add service binding to consuming workers:**

In the worker that needs to call Veta (e.g., an agent worker), add the service binding:

```toml
# wrangler.agent.toml
[[services]]
binding = "VETA"
service = "my-project-veta"

[[env.production.services]]
binding = "VETA"
service = "my-project-veta"
```

**3. Update your dev script to run all workers:**

```json
{
  "scripts": {
    "dev": "wrangler dev -c wrangler.toml -c wrangler.veta.toml -c wrangler.agent.toml --port 8787"
  }
}
```

**4. Call Veta from your worker:**

```typescript
// In your agent worker
interface Env {
  VETA: Fetcher;
}

// Add a note
const response = await env.VETA.fetch(
  new Request('http://veta/notes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      title: 'Meeting notes',
      body: 'Discussed project timeline...',
      tags: ['meetings', 'project-x'],
    }),
  })
);
const { id } = await response.json();

// Search notes
const searchResponse = await env.VETA.fetch(
  new Request('http://veta/grep?q=timeline&tags=meetings')
);
const notes = await searchResponse.json();
```

## HTTP API

The worker exposes a RESTful HTTP API:

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/notes` | Create a note. Body: `{title, body, tags, references?}` |
| `GET` | `/notes` | List notes. Query: `?tags=a,b&limit=20` |
| `GET` | `/notes/:id` | Get a single note |
| `PATCH` | `/notes/:id` | Update a note. Body: `{title?, body?, tags?, references?}` |
| `DELETE` | `/notes/:id` | Delete a note |
| `GET` | `/tags` | List all tags with note counts |
| `GET` | `/grep` | Search notes. Query: `?q=pattern&tags=a,b&case_sensitive=true` |

## Architecture

Veta is written in Rust and compiles to both native (CLI) and WASM (Worker) targets. The architecture maximizes code sharing between the two.

```
veta/
├── crates/
│   ├── veta-core/        # Shared: types, validation, business logic
│   ├── veta-sqlite/      # Native: rusqlite Database implementation
│   ├── veta-d1/          # WASM: D1 Database implementation
│   ├── veta-cli/         # Native: CLI binary
│   └── veta-worker/      # WASM: Cloudflare Worker
└── schema/
    └── migrations/       # Shared SQL migrations
```

### Crates

**`veta-core`** — Pure business logic with no I/O dependencies. Defines:
- Data types (`Note`, `Tag`, `NoteQuery`, etc.)
- The `Database` trait (async, `?Send` for WASM compatibility)
- `VetaService<D: Database>` containing all business logic

**`veta-sqlite`** — Implements `Database` trait using `rusqlite`. Only compiled for native targets.

**`veta-d1`** — Implements `Database` trait using Cloudflare's D1 via `workers-rs`. Only compiled for `wasm32-unknown-unknown`.

**`veta-cli`** — The `veta` command-line tool. Uses `veta-core` + `veta-sqlite`.

**`veta-worker`** — The Cloudflare Worker entry point. Uses `veta-core` + `veta-d1`. Exposes the HTTP API via `workers-rs` Router.

### Database Trait

The key abstraction enabling code sharing:

```rust
#[async_trait(?Send)]  // ?Send required for WASM compatibility
pub trait Database {
    async fn add_note(&self, note: CreateNote) -> Result<i64, Error>;
    async fn get_note(&self, id: i64) -> Result<Option<Note>, Error>;
    async fn list_notes(&self, query: NoteQuery) -> Result<Vec<Note>, Error>;
    async fn update_note(&self, id: i64, update: UpdateNote) -> Result<(), Error>;
    async fn delete_note(&self, id: i64) -> Result<bool, Error>;
    async fn list_tags(&self) -> Result<Vec<TagCount>, Error>;
    async fn grep(&self, pattern: &str, tags: Option<&[String]>, case_sensitive: bool) -> Result<Vec<Note>, Error>;
}
```

All business logic in `VetaService` is generic over this trait, meaning it works identically whether backed by SQLite or D1.

### Build Targets

| Crate | Native | WASM |
|-------|--------|------|
| `veta-core` | ✓ | ✓ |
| `veta-sqlite` | ✓ | ✗ |
| `veta-d1` | ✗ | ✓ |
| `veta-cli` | ✓ | ✗ |
| `veta-worker` | ✗ | ✓ |
