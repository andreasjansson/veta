<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Veta Agent Chat</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    * { font-family: "VT323", monospace; }
    html, body, #root { height: 100%; margin: 0; overflow: hidden; }
    body { background: #0a0a0a; color: #00ff00; font-size: 1.5rem; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  function App() {
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState("");
    const [isConnected, setIsConnected] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef(null);
    const inputRef = useRef(null);
    const wsRef = useRef(null);
    const agentId = useRef(crypto.randomUUID());

    useEffect(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, [messages]);

    useEffect(() => {
      if (!isLoading && isConnected) {
        inputRef.current?.focus();
      }
    }, [isLoading, isConnected]);

    useEffect(() => {
      connectWebSocket();
      return () => wsRef.current?.close();
    }, []);

    const connectWebSocket = () => {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const ws = new WebSocket(`${protocol}//${window.location.host}/agents/chat/${agentId.current}`);
      
      ws.onopen = () => setIsConnected(true);
      ws.onclose = () => {
        setIsConnected(false);
        setTimeout(connectWebSocket, 2000);
      };
      ws.onerror = (e) => console.error("WebSocket error:", e);
      ws.onmessage = (event) => {
        try {
          handleMessage(JSON.parse(event.data));
        } catch (e) {}
      };
      wsRef.current = ws;
    };

    const handleMessage = (data) => {
      if (data.type === "cf_agent_mcp_servers") return;

      if (data.type === "cf_agent_use_chat_response") {
        try {
          const body = JSON.parse(data.body);
          
          if (body.type === "tool-input-available") {
            setMessages(prev => {
              const updated = [...prev];
              const lastMsg = updated[updated.length - 1];
              if (lastMsg?.role === "assistant") {
                lastMsg.toolCalls = lastMsg.toolCalls || [];
                lastMsg.toolCalls.push({ name: body.toolName, input: body.input });
              }
              return [...updated];
            });
          } else if (body.type === "tool-output-available") {
            setMessages(prev => {
              const updated = [...prev];
              const lastMsg = updated[updated.length - 1];
              if (lastMsg?.role === "assistant") {
                lastMsg.toolResults = lastMsg.toolResults || [];
                lastMsg.toolResults.push(body.output);
              }
              return [...updated];
            });
          } else if (body.type === "text-delta" && (body.delta || body.textDelta)) {
            const text = body.delta || body.textDelta;
            setMessages(prev => {
              const updated = [...prev];
              const lastMsg = updated[updated.length - 1];
              if (lastMsg?.role === "assistant") {
                lastMsg.content += text;
              }
              return [...updated];
            });
          } else if (body.type === "finish") {
            setIsLoading(false);
          }
        } catch (e) {}

        if (data.done) setIsLoading(false);
      }
    };

    const sendMessage = (e) => {
      e.preventDefault();
      if (!input.trim() || isLoading || !isConnected) return;

      const userMessage = { role: "user", content: input };
      setMessages(prev => [...prev, userMessage, { role: "assistant", content: "", toolCalls: [], toolResults: [] }]);

      wsRef.current.send(JSON.stringify({
        type: "cf_agent_use_chat_request",
        id: crypto.randomUUID(),
        init: {
          method: "POST",
          body: JSON.stringify({
            messages: [...messages, userMessage].map(m => ({
              id: crypto.randomUUID(),
              role: m.role,
              parts: [{ type: "text", text: m.content }]
            })),
            clientTools: []
          })
        }
      }));

      setInput("");
      setIsLoading(true);
    };

    return (
      <div className="h-full flex flex-col">
        <header className="border-b-2 border-green-500 p-4">
          <h1 className="text-2xl text-green-400">VETA AGENT</h1>
          <p className="text-sm">{isConnected ? "[CONNECTED]" : "[DISCONNECTED]"}</p>
        </header>

        <main className="flex-1 min-h-0 overflow-y-auto p-4 space-y-4">
          {messages.map((msg, i) => (
            <div key={i} className={`flex ${msg.role === "user" ? "justify-end" : "justify-start"}`}>
              <div className={`max-w-[80%] p-3 border-2 ${
                msg.role === "user" 
                  ? "border-cyan-500 text-cyan-400 bg-cyan-950/30" 
                  : "border-green-500 text-green-400 bg-green-950/30"
              }`}>
                {msg.role === "assistant" && msg.toolCalls?.length > 0 && (
                  <div className="mb-2 pb-2 border-b border-green-700">
                    {msg.toolCalls.map((tc, j) => (
                      <div key={j} className="text-yellow-500 text-sm">
                        &gt; {tc.name}({JSON.stringify(tc.input)})
                      </div>
                    ))}
                  </div>
                )}
                {msg.role === "assistant" && msg.toolResults?.length > 0 && (
                  <div className="mb-2 pb-2 border-b border-green-700">
                    {msg.toolResults.map((result, j) => (
                      <div key={j} className="text-emerald-400 text-sm">{result}</div>
                    ))}
                  </div>
                )}
                {msg.role === "assistant" && isLoading && !msg.content && !msg.toolCalls?.length ? (
                  <span className="animate-pulse">_</span>
                ) : (
                  <p className="whitespace-pre-wrap">{msg.content}</p>
                )}
              </div>
            </div>
          ))}
          <div ref={messagesEndRef} />
        </main>

        <form onSubmit={sendMessage} className="p-4 border-t-2 border-green-500">
          <div className="flex gap-2">
            <span className="text-green-500 py-2">&gt;</span>
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Enter command..."
              className="flex-1 p-2 bg-transparent border-2 border-green-700 text-green-400 placeholder-green-800 focus:outline-none focus:border-green-500"
              disabled={!isConnected || isLoading}
            />
            <button
              type="submit"
              disabled={!isConnected || isLoading || !input.trim()}
              className="px-4 py-2 border-2 border-green-500 text-green-400 hover:bg-green-950 disabled:opacity-30 disabled:cursor-not-allowed"
            >
              SEND
            </button>
          </div>
        </form>
      </div>
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
